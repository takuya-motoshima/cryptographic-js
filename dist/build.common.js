"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=e(require("crypto")),r=e(require("util"));const{promisify:i}=r,s=i(t.randomBytes),o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split(""),n="0123456789".split(""),h="CDEHKMPRTUWXY012458".split(""),a="!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split(""),c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),u=[void 0,"hex","base64","url-safe","numeric","distinguishable","ascii-printable","alphanumeric"],f=(e,t)=>({length:r,type:i,characters:s})=>{if(!(r>=0&&Number.isFinite(r)))throw new TypeError("Expected a `length` to be a non-negative finite number");if(void 0!==i&&void 0!==s)throw new TypeError("Expected either `type` or `characters`");if(void 0!==s&&"string"!=typeof s)throw new TypeError("Expected `characters` to be string");if(!u.includes(i))throw new TypeError("Unknown type: "+i);if(void 0===i&&void 0===s&&(i="hex"),"hex"===i||void 0===i&&void 0===s)return t(Math.ceil(.5*r),"hex",r);if("base64"===i)return t(Math.ceil(.75*r),"base64",r);if("url-safe"===i)return e(r,o);if("numeric"===i)return e(r,n);if("distinguishable"===i)return e(r,h);if("ascii-printable"===i)return e(r,a);if("alphanumeric"===i)return e(r,c);if(0===s.length)throw new TypeError("Expected `characters` string length to be greater than or equal to 1");if(s.length>65536)throw new TypeError("Expected `characters` string length to be less or equal to 65536");return e(r,s.split(""))};var l=f((e,r)=>{const i=r.length,s=Math.floor(65536/i)*i-1,o=2*Math.ceil(1.1*e);let n="",h=0;for(;h<e;){const a=t.randomBytes(o);let c=0;for(;c<o&&h<e;){const e=a.readUInt16LE(c);c+=2,e>s||(n+=r[e%i],h++)}}return n},(e,r,i)=>t.randomBytes(e).toString(r).slice(0,i)),p=f(async(e,t)=>{const r=t.length,i=Math.floor(65536/r)*r-1,o=2*Math.ceil(1.1*e);let n="",h=0;for(;h<e;){const a=await s(o);let c=0;for(;c<o&&h<e;){const e=a.readUInt16LE(c);c+=2,e>i||(n+=t[e%r],h++)}}return n},async(e,t,r)=>(await s(e)).toString(t).slice(0,r));l.async=p;class y{constructor(){this.algorithm="",this.keySize=-1,this.ivSize=-1}encrypt(e,r,i,s="base64"){if(Buffer.isBuffer(r)||(r=Buffer.from(r)),Buffer.isBuffer(i)||(i=Buffer.from(i)),Buffer.byteLength(r)!==this.keySize)throw new Error(`Key length must be ${this.keySize} bytes long`);if(Buffer.byteLength(i)!==this.ivSize)throw new Error(`IV length must be ${this.ivSize} bytes long`);const o=t.createCipheriv(this.algorithm,r,i);let n=o.update(e,"utf8",s);return n+=o.final(s),n}decrypt(e,r,i,s="base64"){if(Buffer.isBuffer(r)||(r=Buffer.from(r)),Buffer.isBuffer(i)||(i=Buffer.from(i)),Buffer.byteLength(r)!==this.keySize)throw new Error(`Key length must be ${this.keySize} bytes long`);if(Buffer.byteLength(i)!==this.ivSize)throw new Error(`IV length must be ${this.keySize} bytes long`);const o=t.createDecipheriv(this.algorithm,r,i);let n=o.update(e,s,"utf8");return n+=o.final("utf8"),n}createKey(e="buffer"){return"hex"===e?l({length:this.keySize,type:"hex"}):t.randomBytes(this.keySize)}createIV(e="buffer"){return"hex"===e?l({length:this.ivSize,type:"hex"}):t.randomBytes(this.ivSize)}}exports.AES128CBC=class extends y{constructor(){super(...arguments),this.algorithm="aes-128-cbc",this.keySize=16,this.ivSize=16}},exports.AES128CFB=class extends y{constructor(){super(...arguments),this.algorithm="aes-128-cfb",this.keySize=16,this.ivSize=16}},exports.AES128CTR=class extends y{constructor(){super(...arguments),this.algorithm="aes-128-ctr",this.keySize=16,this.ivSize=16}},exports.AES192CBC=class extends y{constructor(){super(...arguments),this.algorithm="aes-192-cbc",this.keySize=24,this.ivSize=16}},exports.AES192CFB=class extends y{constructor(){super(...arguments),this.algorithm="aes-192-cfb",this.keySize=24,this.ivSize=16}},exports.AES192CTR=class extends y{constructor(){super(...arguments),this.algorithm="aes-192-ctr",this.keySize=24,this.ivSize=16}},exports.AES256CBC=class extends y{constructor(){super(...arguments),this.algorithm="aes-256-cbc",this.keySize=32,this.ivSize=16}},exports.AES256CFB=class extends y{constructor(){super(...arguments),this.algorithm="aes-256-cfb",this.keySize=32,this.ivSize=16}},exports.AES256CTR=class extends y{constructor(){super(...arguments),this.algorithm="aes-256-ctr",this.keySize=32,this.ivSize=16}},exports.version="1.0.0";
